!> Test ADvector init routine
!!
!! Testing array sizes
@Test
subroutine test_ADvector_init() 
    use pfunit_mod
    use mod_kinds, only: rk,ik
    use type_ADvector
    
    implicit none
    type(ADvector_t)   :: vec
    
    
    integer(ik)          :: vsize, nderiv
    
    
    vsize    = 3     ! vector size
    nderiv   = 10    ! number of derivatives to allocate per value
    
    ! Call init method
    call vec%init(vsize,nderiv)
    
    ! Test size of real-valued array
    @assertEqual(vsize,size(vec%vals))
    
    ! Test size of derivative sub-arrays
    @assertEqual(nderiv,size(vec%vals(1)%xp_ad_))
    @assertEqual(nderiv,size(vec%vals(2)%xp_ad_))
    @assertEqual(nderiv,size(vec%vals(3)%xp_ad_))
    
    
end subroutine


!> Test ADvector operators
!!
!! Test ASSIGNMENT of real-array to dual-array
@Test
subroutine test_ADvector_assign_REAL_DUAL() 
    use pfunit_mod
    use mod_kinds, only: rk,ik
    use type_ADvector
    
    implicit none
    real(rk)            :: test_vec(3)
    type(ADvector_t)    :: vec_a, vec_b, vec_c
    
    integer(ik)         :: vsize, nderiv
    
    vsize    = 3     !> vector size
    nderiv   = 3     !> number of derivatives to allocate per value
    
    call vec_a%init(vsize,nderiv)
    call vec_b%init(vsize,nderiv)
    call vec_c%init(vsize,nderiv)
    
    
    test_vec = [1._rk, 2._rk, 3._rk]
    vec_a    = test_vec
    
    
   
    ! Test real values
    @assertEqual(test_vec(1),vec_a%vals(1)%x_ad_)
    @assertEqual(test_vec(2),vec_a%vals(2)%x_ad_)
    @assertEqual(test_vec(3),vec_a%vals(3)%x_ad_)
    
end subroutine


!> Test ADvector operators
!!
!! Test ASSIGNMENT of integer-array to dual-array
@Test
subroutine test_ADvector_assign_LONG_DUAL() 
    use pfunit_mod
    use mod_kinds, only: rk,ik,ilong
    use type_ADvector
    
    implicit none
    integer(ilong)      :: test_int(3)
    real(rk)            :: test_real(3)
    type(ADvector_t)    :: vec_a, vec_b, vec_c
    
    integer(ik)         :: vsize, nderiv
    
    vsize    = 3     !> vector size
    nderiv   = 3     !> number of derivatives to allocate per value
    
    call vec_a%init(vsize,nderiv)
    call vec_b%init(vsize,nderiv)
    call vec_c%init(vsize,nderiv)
    
    
    test_int  = [1, 2, 3]
    test_real = [1._rk, 2._rk, 3._rk]
    
    ! Should convert to REALs
    vec_a    = test_int
    
    ! Test integer values were assigned and converted to real
    @assertEqual(test_real(1),vec_a%vals(1)%x_ad_)
    @assertEqual(test_real(2),vec_a%vals(2)%x_ad_)
    @assertEqual(test_real(3),vec_a%vals(3)%x_ad_)
    
end subroutine



!> Test ADvector operators
!!
!! Test ADDITION of ADvectors
@Test
subroutine test_ADvector_add_ADvec_ADvec() 
    use pfunit_mod
    use mod_kinds, only: rk,ik,ilong
    use type_ADvector
    
    implicit none
    integer(ilong)      :: test_int(3)
    real(rk)            :: test_real(3)
    type(ADvector_t)    :: vec_a, vec_b, vec_c
    
    integer(ik)         :: vsize, nderiv
    
    vsize    = 3     !> vector size
    nderiv   = 3     !> number of derivatives to allocate per value
    
    call vec_a%init(vsize,nderiv)
    call vec_b%init(vsize,nderiv)
    call vec_c%init(vsize,nderiv)
    
    vec_a = [1._rk, 2._rk, 3._rk]
    vec_a%vals(1)%xp_ad_ = [4._rk,  5._rk,  6._rk]
    vec_a%vals(2)%xp_ad_ = [7._rk,  8._rk,  9._rk]
    vec_a%vals(3)%xp_ad_ = [10._rk, 11._rk, 12._rk]

    vec_b = [1._rk, 2._rk, 3._rk]
    vec_b%vals(1)%xp_ad_ = [4._rk,  5._rk,  6._rk]
    vec_b%vals(2)%xp_ad_ = [7._rk,  8._rk,  9._rk]
    vec_b%vals(3)%xp_ad_ = [10._rk, 11._rk, 12._rk]

    ! Test ADvector addition
    vec_c = vec_a + vec_b
    
    ! Test regular values
    @assertEqual(2._rk,vec_c%vals(1)%x_ad_)
    @assertEqual(4._rk,vec_c%vals(2)%x_ad_)
    @assertEqual(6._rk,vec_c%vals(3)%x_ad_)
    
    
    ! Test derivative values
    @assertEqual([8._rk, 10._rk,12._rk],vec_c%vals(1)%xp_ad_)
    @assertEqual([14._rk,16._rk,18._rk],vec_c%vals(2)%xp_ad_)
    @assertEqual([20._rk,22._rk,24._rk],vec_c%vals(3)%xp_ad_)
end subroutine


!> Test ADvector operators
!!
!! Test ADDITION of ADvector with REAL vector
@Test
subroutine test_ADvector_add_ADvec_REAL() 
    use pfunit_mod
    use mod_kinds, only: rk,ik,ilong
    use type_ADvector
    
    implicit none
    integer(ilong)      :: vec_int(3)
    real(rk)            :: vec_real(3)
    type(ADvector_t)    :: vec_a, vec_b, vec_c
    
    integer(ik)         :: vsize, nderiv
    
    vsize    = 3     !> vector size
    nderiv   = 3     !> number of derivatives to allocate per value
    
    call vec_a%init(vsize,nderiv)
    call vec_b%init(vsize,nderiv)
    call vec_c%init(vsize,nderiv)
    
    vec_a = [1._rk, 2._rk, 3._rk]
    vec_a%vals(1)%xp_ad_ = [4._rk,  5._rk,  6._rk]
    vec_a%vals(2)%xp_ad_ = [7._rk,  8._rk,  9._rk]
    vec_a%vals(3)%xp_ad_ = [10._rk, 11._rk, 12._rk]

    vec_real = [1._rk, 2._rk, 3._rk]

    ! Test ADvector addition
    vec_c = vec_a + vec_real
    
    ! Test regular values
    @assertEqual(2._rk,vec_c%vals(1)%x_ad_)
    @assertEqual(4._rk,vec_c%vals(2)%x_ad_)
    @assertEqual(6._rk,vec_c%vals(3)%x_ad_)
    
    
    ! Test derivative values
    @assertEqual([4._rk, 5._rk, 6._rk],vec_c%vals(1)%xp_ad_)
    @assertEqual([7._rk, 8._rk, 9._rk],vec_c%vals(2)%xp_ad_)
    @assertEqual([10._rk,11._rk,12._rk],vec_c%vals(3)%xp_ad_)
end subroutine


!> Test ADvector operators
!!
!! Test ADDITION of REAL vector with ADvecot
@Test
subroutine test_ADvector_add_REAL_ADvec() 
    use pfunit_mod
    use mod_kinds, only: rk,ik,ilong
    use type_ADvector
    
    implicit none
    integer(ilong)      :: vec_int(3)
    real(rk)            :: vec_real(3)
    type(ADvector_t)    :: vec_a, vec_b, vec_c
    
    integer(ik)         :: vsize, nderiv
    
    vsize    = 3     !> vector size
    nderiv   = 3     !> number of derivatives to allocate per value
    
    call vec_a%init(vsize,nderiv)
    call vec_b%init(vsize,nderiv)
    call vec_c%init(vsize,nderiv)
    
    vec_a = [1._rk, 2._rk, 3._rk]
    vec_a%vals(1)%xp_ad_ = [4._rk,  5._rk,  6._rk]
    vec_a%vals(2)%xp_ad_ = [7._rk,  8._rk,  9._rk]
    vec_a%vals(3)%xp_ad_ = [10._rk, 11._rk, 12._rk]

    vec_real = [1._rk, 2._rk, 3._rk]

    ! Test ADvector addition
    vec_c = vec_real + vec_a
    
    ! Test regular values
    @assertEqual(2._rk,vec_c%vals(1)%x_ad_)
    @assertEqual(4._rk,vec_c%vals(2)%x_ad_)
    @assertEqual(6._rk,vec_c%vals(3)%x_ad_)
    
    
    ! Test derivative values
    @assertEqual([4._rk, 5._rk, 6._rk],vec_c%vals(1)%xp_ad_)
    @assertEqual([7._rk, 8._rk, 9._rk],vec_c%vals(2)%xp_ad_)
    @assertEqual([10._rk,11._rk,12._rk],vec_c%vals(3)%xp_ad_)
end subroutine






!> Test ADvector operators
!!
!! Test ADDITION of ADvector with INTEGER vector
@Test
subroutine test_ADvector_add_ADvec_INTEGER() 
    use pfunit_mod
    use mod_kinds, only: rk,ik,ilong
    use type_ADvector
    
    implicit none
    integer(ilong)      :: vec_int(3)
    real(rk)            :: vec_real(3)
    type(ADvector_t)    :: vec_a, vec_b, vec_c
    
    integer(ik)         :: vsize, nderiv
    
    vsize    = 3     !> vector size
    nderiv   = 3     !> number of derivatives to allocate per value
    
    call vec_a%init(vsize,nderiv)
    call vec_b%init(vsize,nderiv)
    call vec_c%init(vsize,nderiv)
    
    vec_a = [1._rk, 2._rk, 3._rk]
    vec_a%vals(1)%xp_ad_ = [4._rk,  5._rk,  6._rk]
    vec_a%vals(2)%xp_ad_ = [7._rk,  8._rk,  9._rk]
    vec_a%vals(3)%xp_ad_ = [10._rk, 11._rk, 12._rk]

    vec_int = [1, 2, 3]

    ! Test ADvector addition
    vec_c = vec_a + vec_int
    
    ! Test regular values
    @assertEqual(2._rk,vec_c%vals(1)%x_ad_)
    @assertEqual(4._rk,vec_c%vals(2)%x_ad_)
    @assertEqual(6._rk,vec_c%vals(3)%x_ad_)
    
    
    ! Test derivative values
    @assertEqual([4._rk, 5._rk, 6._rk],vec_c%vals(1)%xp_ad_)
    @assertEqual([7._rk, 8._rk, 9._rk],vec_c%vals(2)%xp_ad_)
    @assertEqual([10._rk,11._rk,12._rk],vec_c%vals(3)%xp_ad_)
end subroutine




!> Test ADvector operators
!!
!! Test ADDITION of INTEGER vector with ADvec
@Test
subroutine test_ADvector_add_INTEGER_ADvec() 
    use pfunit_mod
    use mod_kinds, only: rk,ik,ilong
    use type_ADvector
    
    implicit none
    integer(ilong)      :: vec_int(3)
    real(rk)            :: vec_real(3)
    type(ADvector_t)    :: vec_a, vec_b, vec_c
    
    integer(ik)         :: vsize, nderiv
    
    vsize    = 3     !> vector size
    nderiv   = 3     !> number of derivatives to allocate per value
    
    call vec_a%init(vsize,nderiv)
    call vec_b%init(vsize,nderiv)
    call vec_c%init(vsize,nderiv)
    
    vec_a = [1._rk, 2._rk, 3._rk]
    vec_a%vals(1)%xp_ad_ = [4._rk,  5._rk,  6._rk]
    vec_a%vals(2)%xp_ad_ = [7._rk,  8._rk,  9._rk]
    vec_a%vals(3)%xp_ad_ = [10._rk, 11._rk, 12._rk]

    vec_int = [1, 2, 3]

    ! Test ADvector addition
    vec_c = vec_int + vec_a
    
    ! Test regular values
    @assertEqual(2._rk,vec_c%vals(1)%x_ad_)
    @assertEqual(4._rk,vec_c%vals(2)%x_ad_)
    @assertEqual(6._rk,vec_c%vals(3)%x_ad_)
    
    
    ! Test derivative values
    @assertEqual([4._rk, 5._rk, 6._rk],vec_c%vals(1)%xp_ad_)
    @assertEqual([7._rk, 8._rk, 9._rk],vec_c%vals(2)%xp_ad_)
    @assertEqual([10._rk,11._rk,12._rk],vec_c%vals(3)%xp_ad_)
end subroutine















