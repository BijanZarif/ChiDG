module test_interpolate_mod
    use pfunit_mod
    use type_chidg,         only: chidg_t
    use mod_kinds,          only: rk,ik
    use mod_constants,      only: ZERO, ONE, TWO, THREE, FIVE, SIX, EIGHT, NINE, TEN, &
                                  XI_MIN, XI_MAX, ETA_MIN, ETA_MAX, ZETA_MIN, ZETA_MAX
    use mod_hdfio,          only: read_grid_hdf
    use mod_interpolate,    only: interpolate
    use mod_grid_operators, only: initialize_variable
    use type_domain,        only: domain_t
    use DNAD_D
    use fcn_constant,       only: constant_f
    implicit none

    public  :: test_interpolate

@TestCase
    type, extends(TestCase) ::  test_interpolate
        type(chidg_t)                   :: chidg
        type(domain_t), allocatable     :: domain(:)
        type(constant_f)                :: fcn

    contains
        procedure   ::  setUp
        procedure   ::  tearDown
    end type test_interpolate


contains
    !> NOTE: make sure to use 'this' instead of 'self' since these are over-writting a derived type 
    !! procedure. The argument names have to match
    subroutine setUp(this)
        class(test_interpolate),    intent(inout)   :: this
        integer(ik)                                 :: nterms_s, ivar
        
        associate (dom => this%domain)
    
            
            !> Initialize ChiDG environment
            call this%chidg%init()
    
    
            !> Read 3x3x3 element grid
            call read_grid_hdf('D1_E27_M1.h5', this%domain)
    
    
            !> Initialize domain numerics
            nterms_s = 8
            call this%domain(1)%init_sol('Scalar',nterms_s)
    
    
            !> Initialized solution to constant values
            ivar = this%domain(1)%eqnset%get_var('u')               !> Get variable index
            call this%fcn%set(5._rk)                                !> Set constant function value
            call initialize_variable(this%domain(1),ivar,this%fcn)  !> Initialize variable using constant function
    
    
        end associate        
    end subroutine
    
    subroutine tearDown(this)
        class(test_interpolate),    intent(inout)   :: this
        
    end subroutine


!------------------------------------------------------------------------------------------------------


!> Test element metric entries at quadrature points
@Test
    subroutine test_interpolate_element_standard(self)
        class(test_interpolate),    intent(inout)   :: self
        
        integer(ik)                 :: ielem, ivar, ngq
        real(rk), allocatable       :: u_gq(:), u_ref(:)
        real(rk)                    :: tol
        
        associate ( elems => self%domain(1)%mesh%elems, q => self%domain(1)%q, rhs => self%domain(1)%rhs )        
            tol   = 1.e-13_rk
            ielem = 14
            ivar  = 1

            ngq = elems(ielem)%gq%nnodes_v

            allocate(u_gq(ngq))
            allocate(u_ref(ngq))
            
            
            !> PROCEDURE BEING TESTED
            call interpolate(elems,q,ielem,ivar,u_gq)
            
            
            !> Initialize reference
            u_ref = self%fcn%value_ 
            
            !> Test that standard interpolation to quadrature 
            !! on an element volume is producing expected results
            @assertEqual(u_ref,u_gq,tol)
            
        end associate
    end subroutine


@Test
    subroutine test__interpolate_elements_autodiff__values__neighbor(self)
        class(test_interpolate),    intent(inout)   :: self
        
        integer(ik)                 :: ielem, ielem_s, ivar, ngq
        type(AD_D), allocatable     :: u_gq(:)
        real(rk),   allocatable     :: u_ref(:)
        real(rk)                    :: tol
        
        
        associate ( elems => self%domain(1)%mesh%elems, q => self%domain(1)%q, rhs => self%domain(1)%rhs )        
            ielem   = 14    !> given element
            ielem_s = 15    !> a seed element, so all derivative arrays should be seeded to zero
            tol   = 1.e-13_rk
            ivar  = self%domain(1)%eqnset%get_var('u')

            ngq = elems(ielem)%gq%nnodes_v

            !> Allocate number of AD variables for data at GQ nodes. Derivative arrays are not yet allocated
            allocate(u_gq(ngq))
            allocate(u_ref(ngq))
            
            
            !> PROCEDURE BEING TESTED
            call interpolate(elems,q,ielem,ivar,u_gq,ielem_s)
            
            
            !> Initialize reference
            u_ref = self%fcn%value_ 
            
            !> Test that interpolation to quadrature nodes from modes to autodiff variables 
            !! on an element volume is producing expected results
            @assertEqual(u_ref,u_gq(:)%x_ad_,tol)
            
        end associate
        
    end subroutine


@Test
    subroutine test__interpolate_elements_autodiff__derivs__neighbor(self)
        class(test_interpolate),    intent(inout)   :: self
        
        integer(ik)                 :: ielem, ielem_s, ivar, ngq, igq
        type(AD_D), allocatable     :: u_gq(:)
        real(rk),   allocatable     :: deriv_ref(:)
        real(rk)                    :: tol
        
        
        associate ( elems => self%domain(1)%mesh%elems, q => self%domain(1)%q, rhs => self%domain(1)%rhs )
            ielem   = 14    !> given element
            ielem_s = 15    !> a seed element, so all derivative arrays should be seeded to zero        
            tol   = 1.e-13_rk
            ivar  = self%domain(1)%eqnset%get_var('u')

            ngq = elems(ielem)%gq%nnodes_v

            !> Allocate number of AD variables for data at GQ nodes. Derivative arrays are not yet allocated
            allocate(u_gq(ngq))
            allocate(deriv_ref(ngq))
            
            
            !> PROCEDURE BEING TESTED
            call interpolate(elems,q,ielem,ivar,u_gq,ielem_s)
            
            
            !> Initialize reference
            deriv_ref = ZERO    !> all derivatives should be zero, since the neightboring element is being seeded 
            
            
            !> Test that the derivatives for each gq variable are zero
            do igq = 1,ngq
                @assertEqual(deriv_ref,u_gq(ngq)%xp_ad_,tol)
            end do
            
        end associate
        
    end subroutine
    
    
    
    
    
    
    
    @Test
    subroutine test__interpolate_elements_autodiff__values__current(self)
        class(test_interpolate),    intent(inout)   :: self
        
        integer(ik)                 :: ielem, ielem_s, ivar, ngq
        type(AD_D), allocatable     :: u_gq(:)
        real(rk),   allocatable     :: u_ref(:)
        real(rk)                    :: tol
        
        
        associate ( elems => self%domain(1)%mesh%elems, q => self%domain(1)%q, rhs => self%domain(1)%rhs )
            ielem   = 14    !> given element
            ielem_s = 14    !> a seed element, so all derivative arrays should be seeded to zero
            tol   = 1.e-13_rk
            ivar  = self%domain(1)%eqnset%get_var('u')
            
            ngq = elems(ielem)%gq%nnodes_v  !> Number of quadrature nodes
            
            !> Allocate number of AD variables for data at GQ nodes. Derivative arrays are not yet allocated
            allocate(u_gq(ngq))
            allocate(u_ref(ngq))
            
            
            !> PROCEDURE BEING TESTED
            call interpolate(elems,q,ielem,ivar,u_gq,ielem_s)
            
            
            !> Initialize reference
            u_ref = self%fcn%value_ 
            
            !> Test that interpolation to quadrature nodes from modes to autodiff variables 
            !! on an element volume is producing expected results
            @assertEqual(u_ref,u_gq(:)%x_ad_,tol)
            
        end associate
        
    end subroutine


@Test
    subroutine test__interpolate_elements_autodiff__derivs__current(self)
        class(test_interpolate),    intent(inout)   :: self
        
        integer(ik)                 :: ielem, ielem_s, ivar, ngq, igq
        type(AD_D), allocatable     :: u_gq(:)
        real(rk),   allocatable     :: deriv_ref(:)
        real(rk)                    :: tol
        
        
        associate ( elems => self%domain(1)%mesh%elems, q => self%domain(1)%q, rhs => self%domain(1)%rhs )        
            ielem   = 14    !> given element
            ielem_s = 14    !> a seed element, so all derivative arrays should be seeded to zero
            tol   = 1.e-13_rk
            ivar  = self%domain(1)%eqnset%get_var('u')

            ngq = elems(ielem)%gq%nnodes_v      !> Number of quadrature nodes

            !> Allocate number of AD variables for data at GQ nodes. Derivative arrays are not yet allocated
            allocate(u_gq(ngq))
            allocate(deriv_ref(ngq))
            
            
            !> PROCEDURE BEING TESTED
            call interpolate(elems,q,ielem,ivar,u_gq,ielem_s)
            
            
            !> Initialize reference
            deriv_ref    = ZERO         !> all derivatives should be zero, since the neighboring element is being seeded 
            
            
            !> Test that the derivatives for each gq variable are zero
            do igq = 1,ngq
                deriv_ref = elems(ielem)%gq%vol%val(igq,:)      !> Set expected derivatives. Here it turns out to be the igq row of the quadrature matrix
                                                                !> This is because the seeded derivatives are one, so the values are not amplified.
                
                @assertEqual(deriv_ref,u_gq(igq)%xp_ad_,tol)
                
                deriv_ref = ZERO                                !> Reset to zero
            end do
            
        end associate
        
    end subroutine
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    





end module test_interpolate_mod