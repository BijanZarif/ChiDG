@Test
subroutine test_integrate_boundary_unit_constant()
    use pfunit_mod
    use mod_kinds,          only: rk, ik
    use mod_constants,      only: ONE
    use mod_integrate,      only: integrate_boundary_scalar_flux
    use type_chidg,         only: chidg_t
    use type_point,         only: point_t
    use atype_function,     only: function_t
    use mod_function,       only: create_function
    use mod_testutils,      only: meshgen
    use mod_grid_operators, only: initialize_variable
    use DNAD_D
    implicit none



    type(point_t),      allocatable     :: pts(:,:,:)
    type(chidg_t)                       :: chidg
    integer(ik)                         :: nterms_c, nterms_s, iblk, ivar, idomain, igq, ngq
    type(AD_D),         allocatable     :: flux(:)
    class(function_t),  allocatable     :: constant
    real(rk)                            :: integral, ref_integral


    !
    ! Initialize chidg environment
    !
    call chidg%init('env')
    
    

    !
    ! Initialize mesh and scalar equation set
    !
    call meshgen('111u',pts)
    idomain  = 1
    nterms_c = 8
    nterms_s = 1



    !allocate(chidg%data%domains(1))
    !call chidg%data%domains(1)%init_geom(idomain,nterms_c,pts)
    !call chidg%data%domains(1)%init_sol('scalar',nterms_s)


    call chidg%data%add_domain('D_01',pts,nterms_c,'Scalar',nterms_s)

    call chidg%data%init_sdata()

    !
    ! Initialize solution to constant value
    !
    call create_function(constant,'constant')
    call constant%set('val',1._rk)
    call initialize_variable(chidg%data,1,constant)

    
    !
    ! Allocate flux array
    !
    associate ( faces => chidg%data%mesh(1)%faces, sdata => chidg%data%sdata )
    ngq = faces(1,1)%gq%face%nnodes
    allocate(flux(ngq))
    
    do igq = 1,size(flux)
        allocate(flux(igq)%xp_ad_(1))
    end do


    !
    ! Compute constant flux on the face and dot with face normals
    !
    flux = ONE*faces(1,1)%norm(:,1)

    

    ivar    = 1
    iblk    = 7
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    call integrate_boundary_scalar_flux(faces(1,1),sdata,idomain,ivar,iblk,flux)


    integral = sdata%rhs%dom(1)%lvecs(1)%vec(1)

    end associate

    ref_integral = -4._rk
    @assertEqual(ref_integral,integral)

end subroutine













@Test
subroutine test_integrate_boundary_nonunit_constant()
    use pfunit_mod
    use mod_kinds,          only: rk, ik
    use mod_constants,      only: ONE, XI_MIN, XI_MAX, ETA_MIN, ETA_MAX, ZETA_MIN, ZETA_MAX
    use mod_integrate,      only: integrate_boundary_scalar_flux
    use type_chidg,         only: chidg_t
    use type_point,         only: point_t
    use atype_function,     only: function_t
    use mod_function,       only: create_function
    use mod_testutils,      only: meshgen
    use mod_grid_operators, only: initialize_variable
    use DNAD_D
    implicit none



    type(point_t),      allocatable     :: pts(:,:,:)
    type(chidg_t)                       :: chidg
    integer(ik)                         :: nterms_c, nterms_s, igq, ngq, ivar, iblk, idomain
    type(AD_D),         allocatable     :: flux(:)
    class(function_t),  allocatable     :: constant
    real(rk)                            :: integral, ref_integral


    !
    ! Initialize chidg environment
    !
    call chidg%init('env')
    
    

    !
    ! Initialize mesh and scalar equation set
    !
    call meshgen('111',pts)
    nterms_c = 8
    nterms_s = 1


    call chidg%data%add_domain('D_01',pts,nterms_c,'scalar',nterms_s)
    call chidg%data%init_sdata()

    !
    ! Initialize solution to constant value
    !
    call create_function(constant,'constant')
    call constant%set('val',1._rk)
    call initialize_variable(chidg%data,1,constant)

    
    !
    ! Allocate flux array
    !
    associate ( faces => chidg%data%mesh(1)%faces, sdata => chidg%data%sdata )
    ngq = faces(1,1)%gq%face%nnodes
    allocate(flux(ngq))
    
    do igq = 1,size(flux)
        allocate(flux(igq)%xp_ad_(1))
    end do


    !
    ! Compute constant flux on the face and dot with face normals
    !
    flux = ONE*faces(1,1)%norm(:,1)

    

    idomain  = 1
    ivar = 1
    iblk = 7
    !!!!!!!!!!!!!!!!!!!!!!!
    ! Test Face XI_MIN
    !!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    call integrate_boundary_scalar_flux(faces(1,XI_MIN),sdata,idomain,ivar,iblk,flux)


    integral = sdata%rhs%dom(1)%lvecs(1)%vec(1)


    ref_integral = -1._rk
    @assertEqual(ref_integral,integral)

    call sdata%rhs%clear()


    !!!!!!!!!!!!!!!!!!!!!!!
    ! Test Face XI_MAX
    !!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    flux = ONE*faces(1,XI_MAX)%norm(:,1)
    call integrate_boundary_scalar_flux(faces(1,XI_MAX),sdata,idomain,ivar,iblk,flux)


    integral = sdata%rhs%dom(1)%lvecs(1)%vec(1)


    ref_integral = 1._rk
    @assertEqual(ref_integral,integral)


    call sdata%rhs%clear()



    !!!!!!!!!!!!!!!!!!!!!!!
    ! Test Face ETA_MIN
    !!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    flux = ONE*faces(1,ETA_MIN)%norm(:,2)
    call integrate_boundary_scalar_flux(faces(1,ETA_MIN),sdata,idomain,ivar,iblk,flux)


    integral = sdata%rhs%dom(1)%lvecs(1)%vec(1)


    ref_integral = -1._rk
    @assertEqual(ref_integral,integral)


    call sdata%rhs%clear()





    !!!!!!!!!!!!!!!!!!!!!!!
    ! Test Face ETA_MAX
    !!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    flux = ONE*faces(1,ETA_MAX)%norm(:,2)
    call integrate_boundary_scalar_flux(faces(1,ETA_MAX),sdata,idomain,ivar,iblk,flux)


    integral = sdata%rhs%dom(1)%lvecs(1)%vec(1)


    ref_integral = 1._rk
    @assertEqual(ref_integral,integral)


    call sdata%rhs%clear()




    !!!!!!!!!!!!!!!!!!!!!!!
    ! Test Face ZETA_MIN
    !!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    flux = ONE*faces(1,ZETA_MIN)%norm(:,3)
    call integrate_boundary_scalar_flux(faces(1,ZETA_MIN),sdata,idomain,ivar,iblk,flux)


    integral = sdata%rhs%dom(1)%lvecs(1)%vec(1)


    ref_integral = -1._rk
    @assertEqual(ref_integral,integral)


    call sdata%rhs%clear()




    !!!!!!!!!!!!!!!!!!!!!!!
    ! Test Face ZETA_MAX
    !!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    flux = ONE*faces(1,ZETA_MAX)%norm(:,3)
    call integrate_boundary_scalar_flux(faces(1,ZETA_MAX),sdata,idomain,ivar,iblk,flux)


    integral = sdata%rhs%dom(1)%lvecs(1)%vec(1)


    ref_integral = 1._rk
    @assertEqual(ref_integral,integral)


    call sdata%rhs%clear()



    end associate
end subroutine


















