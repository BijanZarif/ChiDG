@Test
subroutine test_integrate_boundary_unit_constant()
    use pfunit_mod
    use mod_kinds,          only: rk, ik
    use mod_constants,      only: ONE
    use mod_integrate,      only: integrate_boundary_scalar_flux
    use type_chidg,         only: chidg_t
    use type_point,         only: point_t
    use atype_function,     only: function_t
    use mod_function,       only: create_function
    use mod_testutils,      only: meshgen
    use mod_grid_operators, only: initialize_variable
    use DNAD_D



    type(point_t),      allocatable     :: pts(:,:,:)
    type(chidg_t)                       :: chidg
    integer(ik)                         :: nterms_c, nterms_s
    type(AD_D),         allocatable     :: flux(:)
    class(function_t),  allocatable     :: constant
    real(rk)                            :: integral, ref_integral


    !
    ! Initialize chidg environment
    !
    call chidg%init('env')
    
    

    !
    ! Initialize mesh and scalar equation set
    !
    call meshgen('111u',pts)
    call chidg%set('ndomains','')
    nterms_c = 8
    nterms_s = 1
    call chidg%domains(1)%init_geom(nterms_c,pts)
    call chidg%domains(1)%init_sol('scalar',nterms_s)



    !
    ! Initialize solution to constant value
    !
    call create_function(constant,'constant')
    call constant%set('val',1._rk)
    call initialize_variable(chidg%domains(1),1,constant)

    
    !
    ! Allocate flux array
    !
    associate ( faces => chidg%domains(1)%mesh%faces, sdata => chidg%domains(1)%sdata )
    ngq = faces(1,1)%gq%face%nnodes
    allocate(flux(ngq))
    
    do igq = 1,size(flux)
        allocate(flux(igq)%xp_ad_(1))
    end do


    !
    ! Compute constant flux on the face and dot with face normals
    !
    flux = ONE*faces(1,1)%norm(:,1)

    

    ivar = 1
    iblk = 7
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    call integrate_boundary_scalar_flux(faces(1,1),sdata,ivar,iblk,flux)


    integral = sdata%rhs%lvecs(1)%vec(1)

    end associate

    ref_integral = -4._rk
    @assertEqual(ref_integral,integral)

end subroutine













@Test
subroutine test_integrate_boundary_nonunit_constant()
    use pfunit_mod
    use mod_kinds,          only: rk, ik
    use mod_constants,      only: ONE, XI_MIN, XI_MAX, ETA_MIN, ETA_MAX, ZETA_MIN, ZETA_MAX
    use mod_integrate,      only: integrate_boundary_scalar_flux
    use type_chidg,         only: chidg_t
    use type_point,         only: point_t
    use atype_function,     only: function_t
    use mod_function,       only: create_function
    use mod_testutils,      only: meshgen
    use mod_grid_operators, only: initialize_variable
    use DNAD_D



    type(point_t),      allocatable     :: pts(:,:,:)
    type(chidg_t)                       :: chidg
    integer(ik)                         :: nterms_c, nterms_s
    type(AD_D),         allocatable     :: flux(:)
    class(function_t),  allocatable     :: constant
    real(rk)                            :: integral, ref_integral


    !
    ! Initialize chidg environment
    !
    call chidg%init('env')
    
    

    !
    ! Initialize mesh and scalar equation set
    !
    call meshgen('111',pts)
    call chidg%set('ndomains','')
    nterms_c = 8
    nterms_s = 1
    call chidg%domains(1)%init_geom(nterms_c,pts)
    call chidg%domains(1)%init_sol('scalar',nterms_s)



    !
    ! Initialize solution to constant value
    !
    call create_function(constant,'constant')
    call constant%set('val',1._rk)
    call initialize_variable(chidg%domains(1),1,constant)

    
    !
    ! Allocate flux array
    !
    associate ( faces => chidg%domains(1)%mesh%faces, sdata => chidg%domains(1)%sdata )
    ngq = faces(1,1)%gq%face%nnodes
    allocate(flux(ngq))
    
    do igq = 1,size(flux)
        allocate(flux(igq)%xp_ad_(1))
    end do


    !
    ! Compute constant flux on the face and dot with face normals
    !
    flux = ONE*faces(1,1)%norm(:,1)

    

    ivar = 1
    iblk = 7
    !!!!!!!!!!!!!!!!!!!!!!!
    ! Test Face XI_MIN
    !!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    call integrate_boundary_scalar_flux(faces(1,XI_MIN),sdata,ivar,iblk,flux)


    integral = sdata%rhs%lvecs(1)%vec(1)


    ref_integral = -1._rk
    @assertEqual(ref_integral,integral)

    call sdata%rhs%clear()


    !!!!!!!!!!!!!!!!!!!!!!!
    ! Test Face XI_MAX
    !!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    flux = ONE*faces(1,XI_MAX)%norm(:,1)
    call integrate_boundary_scalar_flux(faces(1,XI_MAX),sdata,ivar,iblk,flux)


    integral = sdata%rhs%lvecs(1)%vec(1)


    ref_integral = 1._rk
    @assertEqual(ref_integral,integral)


    call sdata%rhs%clear()



    !!!!!!!!!!!!!!!!!!!!!!!
    ! Test Face ETA_MIN
    !!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    flux = ONE*faces(1,ETA_MIN)%norm(:,2)
    call integrate_boundary_scalar_flux(faces(1,ETA_MIN),sdata,ivar,iblk,flux)


    integral = sdata%rhs%lvecs(1)%vec(1)


    ref_integral = -1._rk
    @assertEqual(ref_integral,integral)


    call sdata%rhs%clear()





    !!!!!!!!!!!!!!!!!!!!!!!
    ! Test Face ETA_MAX
    !!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    flux = ONE*faces(1,ETA_MAX)%norm(:,2)
    call integrate_boundary_scalar_flux(faces(1,ETA_MAX),sdata,ivar,iblk,flux)


    integral = sdata%rhs%lvecs(1)%vec(1)


    ref_integral = 1._rk
    @assertEqual(ref_integral,integral)


    call sdata%rhs%clear()




    !!!!!!!!!!!!!!!!!!!!!!!
    ! Test Face ZETA_MIN
    !!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    flux = ONE*faces(1,ZETA_MIN)%norm(:,3)
    call integrate_boundary_scalar_flux(faces(1,ZETA_MIN),sdata,ivar,iblk,flux)


    integral = sdata%rhs%lvecs(1)%vec(1)


    ref_integral = -1._rk
    @assertEqual(ref_integral,integral)


    call sdata%rhs%clear()




    !!!!!!!!!!!!!!!!!!!!!!!
    ! Test Face ZETA_MAX
    !!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    flux = ONE*faces(1,ZETA_MAX)%norm(:,3)
    call integrate_boundary_scalar_flux(faces(1,ZETA_MAX),sdata,ivar,iblk,flux)


    integral = sdata%rhs%lvecs(1)%vec(1)


    ref_integral = 1._rk
    @assertEqual(ref_integral,integral)


    call sdata%rhs%clear()



    end associate
end subroutine






















@Test
subroutine test_integrate_boundary_nonunit_skewed_constant()
    use pfunit_mod
    use mod_kinds,          only: rk, ik
    use mod_constants,      only: ONE, XI_MIN, XI_MAX, ETA_MIN, ETA_MAX, ZETA_MIN, ZETA_MAX
    use mod_integrate,      only: integrate_boundary_scalar_flux
    use type_chidg,         only: chidg_t
    use type_point,         only: point_t
    use atype_function,     only: function_t
    use mod_function,       only: create_function
    use mod_testutils,      only: meshgen
    use mod_grid_operators, only: initialize_variable
    use DNAD_D



    type(point_t),      allocatable     :: pts(:,:,:)
    type(chidg_t)                       :: chidg
    integer(ik)                         :: nterms_c, nterms_s
    type(AD_D),         allocatable     :: flux(:)
    class(function_t),  allocatable     :: constant
    real(rk)                            :: integral, ref_integral, tol
    real(rk)                            :: x(8), y(8), z(8)

    tol = 1.e-15

    !
    ! Initialize chidg environment
    !
    call chidg%init('env')
    
    

    !
    ! Initialize mesh and scalar equation set
    !
    allocate(pts(2,2,2))

    x = [0._rk, 0.5_rk, 0._rk, 0.5_rk, 0._rk, 0.5_rk, 0._rk, 0.5_rk]
    y = [0._rk, 0.001_rk, 0.3_rk, 0.5_rk, 0._rk, 0.001_rk, 0.3_rk, 0.5_rk]
    z = [0._rk, 0._rk, 0._rk, 0._rk, 0.1_rk, 0.1_rk, 0.1_rk, 0.1_rk]

    call pts(1,1,1)%set(x(1),y(1),z(1))
    call pts(2,1,1)%set(x(2),y(2),z(2))
    call pts(1,2,1)%set(x(3),y(3),z(3))
    call pts(2,2,1)%set(x(4),y(4),z(4))
    call pts(1,1,2)%set(x(5),y(5),z(5))
    call pts(2,1,2)%set(x(6),y(6),z(6))
    call pts(1,2,2)%set(x(7),y(7),z(7))
    call pts(2,2,2)%set(x(8),y(8),z(8))

    call chidg%set('ndomains','')
    nterms_c = 8
    nterms_s = 1
    call chidg%domains(1)%init_geom(nterms_c,pts)
    call chidg%domains(1)%init_sol('scalar',nterms_s)



    !
    ! Initialize solution to constant value
    !
    call create_function(constant,'constant')
    call constant%set('val',1._rk)
    call initialize_variable(chidg%domains(1),1,constant)

    
    !
    ! Allocate flux array
    !
    associate ( faces => chidg%domains(1)%mesh%faces, sdata => chidg%domains(1)%sdata )
    ngq = faces(1,1)%gq%face%nnodes
    allocate(flux(ngq))
    
    do igq = 1,size(flux)
        allocate(flux(igq)%xp_ad_(1))
    end do


    !
    ! Compute constant flux on the face and dot with face normals
    !
    flux = ONE*faces(1,1)%norm(:,1)

    

    ivar = 1
    iblk = 7
    !!!!!!!!!!!!!!!!!!!!!!!
    ! Test Face XI_MIN
    !!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    call integrate_boundary_scalar_flux(faces(1,XI_MIN),sdata,ivar,iblk,flux)


    integral = sdata%rhs%lvecs(1)%vec(1)


    ref_integral = -0.03_rk
    @assertEqual(ref_integral,integral,tol)

    call sdata%rhs%clear()


!    !!!!!!!!!!!!!!!!!!!!!!!
!    ! Test Face XI_MAX
!    !!!!!!!!!!!!!!!!!!!!!!!
!    !
!    ! Integrate boundary. THIS IS BEING TESTED
!    !
!    flux = ONE*faces(1,XI_MAX)%norm(:,1)
!    call integrate_boundary_scalar_flux(faces(1,XI_MAX),sdata,ivar,iblk,flux)
!
!
!    integral = sdata%rhs%lvecs(1)%vec(1)
!
!
!    ref_integral = 0.03_rk
!    @assertEqual(ref_integral,integral,tol)
!
!
!    call sdata%rhs%clear()
!


    !!!!!!!!!!!!!!!!!!!!!!!
    ! Test Face ETA_MIN
    !!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Integrate boundary. THIS IS BEING TESTED
    !
    flux = ZERO
    print*, faces(1,ETA_MIN)%norm(:,1)
    print*, faces(1,ETA_MIN)%norm(:,2)
    print*, faces(1,ETA_MIN)%norm(:,3)
    !flux = flux + ONE*faces(1,ETA_MIN)%norm(:,1)*faces(1,ETA_MIN)%unorm(:,1)
    !!flux = flux + ONE*faces(1,ETA_MIN)%norm(:,2)*faces(1,ETA_MIN)%unorm(:,2)
    !flux = flux + ONE*faces(1,ETA_MIN)%norm(:,3)*faces(1,ETA_MIN)%unorm(:,3)
    flux = flux + ONE*faces(1,ETA_MIN)%norm(:,1)
    flux = flux + ONE*faces(1,ETA_MIN)%norm(:,2)
    flux = flux + ONE*faces(1,ETA_MIN)%norm(:,3)

    !flux = ONE

    call integrate_boundary_scalar_flux(faces(1,ETA_MIN),sdata,ivar,iblk,flux)


    integral = sdata%rhs%lvecs(1)%vec(1)


    ref_integral = -sqrt((0.5_rk)**2._rk  +  (0.001_rk)**2._rk)*(0.1_rk)

    @assertEqual(ref_integral,integral,tol)


    call sdata%rhs%clear()





!    !!!!!!!!!!!!!!!!!!!!!!!
!    ! Test Face ETA_MAX
!    !!!!!!!!!!!!!!!!!!!!!!!
!    !
!    ! Integrate boundary. THIS IS BEING TESTED
!    !
!    flux = ONE*faces(1,ETA_MAX)%norm(:,2)
!    call integrate_boundary_scalar_flux(faces(1,ETA_MAX),sdata,ivar,iblk,flux)
!
!
!    integral = sdata%rhs%lvecs(1)%vec(1)
!
!
!    ref_integral = 1._rk
!    @assertEqual(ref_integral,integral)
!
!
!    call sdata%rhs%clear()
!
!
!
!
!    !!!!!!!!!!!!!!!!!!!!!!!
!    ! Test Face ZETA_MIN
!    !!!!!!!!!!!!!!!!!!!!!!!
!    !
!    ! Integrate boundary. THIS IS BEING TESTED
!    !
!    flux = ONE*faces(1,ZETA_MIN)%norm(:,3)
!    call integrate_boundary_scalar_flux(faces(1,ZETA_MIN),sdata,ivar,iblk,flux)
!
!
!    integral = sdata%rhs%lvecs(1)%vec(1)
!
!
!    ref_integral = -1._rk
!    @assertEqual(ref_integral,integral)
!
!
!    call sdata%rhs%clear()
!
!
!
!
!    !!!!!!!!!!!!!!!!!!!!!!!
!    ! Test Face ZETA_MAX
!    !!!!!!!!!!!!!!!!!!!!!!!
!    !
!    ! Integrate boundary. THIS IS BEING TESTED
!    !
!    flux = ONE*faces(1,ZETA_MAX)%norm(:,3)
!    call integrate_boundary_scalar_flux(faces(1,ZETA_MAX),sdata,ivar,iblk,flux)
!
!
!    integral = sdata%rhs%lvecs(1)%vec(1)
!
!
!    ref_integral = 1._rk
!    @assertEqual(ref_integral,integral)
!
!
!    call sdata%rhs%clear()
!


    end associate
end subroutine






