module mod_interpolate
#include <messenger.h>
    use mod_kinds,          only: rk,ik
    use mod_constants,      only: CHIMERA
    use DNAD_D
    use type_mesh,          only: mesh_t
    use type_seed,          only: seed_t
    use type_chidgVector,   only: chidgVector_t

    implicit none




    interface interpolate_element
        module procedure    interpolate_element_autodiff, interpolate_element_standard
    end interface

    interface interpolate_face
        module procedure    interpolate_face_autodiff,    interpolate_face_standard
    end interface





contains


    !> Compute variable at quadrature nodes.
    !!
    !!
    !!
    !!
    !----------------------------------------------------------------
    subroutine interpolate_element_autodiff(mesh,q,idom,ielem,ivar,var_gq,seed)
        type(mesh_t),        intent(in)      :: mesh(:)
        type(chidgVector_t), intent(in)      :: q
        integer(ik),         intent(in)      :: idom
        integer(ik),         intent(in)      :: ielem
        integer(ik),         intent(in)      :: ivar
        type(AD_D),          intent(inout)   :: var_gq(:)
        type(seed_t),        intent(in)      :: seed

        type(AD_D)  :: qdiff(mesh(idom)%elems(ielem)%nterms_s)
        integer(ik) :: nderiv, set_deriv, iterm, igq, i, neqns_seed, nterms_s_seed
        integer(ik) :: idom_seed, ielem_seed
        logical     :: linearize_me


        !
        ! Get domain/element index that is being differentiated
        !
        idom_seed  = seed%idom
        ielem_seed = seed%ielem



        !
        ! Get the number of degrees of freedom for the seed element
        ! and set this as the number of partial derivatives to track
        !
        if (ielem_seed == 0) then
            !
            ! If ielem_seed == 0 then we aren't interested in tracking derivatives
            !
            nderiv = 1

        !
        ! Get number of unknowns from element being linearized
        !
        else

            !
            ! Get number of equations and terms in solution expansions
            !
            neqns_seed    = mesh(idom_seed)%elems(ielem_seed)%neqns
            nterms_s_seed = mesh(idom_seed)%elems(ielem_seed)%nterms_s

            !
            ! Compute number of unknowns in the seed element, which is the number of partial derivatives we are tracking
            !
            nderiv = neqns_seed * nterms_s_seed
        end if



        !
        ! Allocate the derivative array for each autodiff variable
        ! MIGHT NOT NEED THIS IF IT GETS AUTOMATICALLY ALLOCATED ON ASSIGNMENT -- TEST
        !
        do igq = 1,size(var_gq)
            var_gq(igq) = AD_D(nderiv)
        end do



        !
        ! If the current element is being differentiated (ielem == ielem_seed)
        ! then copy the solution modes to local AD variable and seed derivatives
        !
        linearize_me = ( (idom == idom_seed) .and. (ielem == ielem_seed) )

        if (linearize_me) then

            !
            ! Allocate derivative arrays for temporary solution variable
            !
            do iterm = 1,mesh(idom)%elems(ielem)%nterms_s
                qdiff(iterm) = AD_D(nderiv)
            end do


            !
            ! Copy the solution variables from 'q' to 'qdiff'
            !
            qdiff = q%dom(idom)%lvecs(ielem)%getvar(ivar)


            !
            ! Loop through the terms in qdiff
            !
            do iterm = 1,size(qdiff)
                !
                ! For the given term, seed its appropriate derivative
                !
                set_deriv = (ivar - 1)*mesh(idom)%elems(ielem)%nterms_s + iterm
                qdiff(iterm)%xp_ad_(set_deriv) = 1.0_rk
            end do


            !
            ! Interpolate solution to GQ nodes via matrix-vector multiplication
            !
            var_gq = matmul(mesh(idom)%elems(ielem)%gq%vol%val,qdiff)

        else
            !
            ! If the solution variable derivatives dont need initialized
            ! then just use the q(ielem) values and derivatives get
            ! initialized to zero
            !
            var_gq = matmul(mesh(idom)%elems(ielem)%gq%vol%val,q%dom(idom)%lvecs(ielem)%getvar(ivar))
        end if


    end subroutine










    !> Compute variable at quadrature nodes.
    !!
    !!
    !!
    !!
    !----------------------------------------------------------------
    subroutine interpolate_face_autodiff(mesh,q,idom,ielem,iface,ivar,var_gq,seed)
        type(mesh_t),           intent(in)              :: mesh(:)
        type(chidgVector_t),    intent(in)              :: q
        integer(ik),            intent(in)              :: idom
        integer(ik),            intent(in)              :: ielem
        integer(ik),            intent(in)              :: iface
        integer(ik),            intent(in)              :: ivar
        type(AD_D),             intent(inout)           :: var_gq(:)
        type(seed_t),           intent(in)              :: seed

        type(AD_D), allocatable  :: qdiff(:)
        integer(ik) :: nderiv, set_deriv, iterm, igq, nterms_s, ierr, neqns_seed, nterms_s_seed
        integer(ik) :: idom_seed, ielem_seed
        logical     :: linearize_me          = .false.
        logical     :: chimera_interpolation = .false.


        !
        ! Test for CHIMERA interpolation. This would possibly be set in the compute_neighbor_face routine
        !
        if ( iface == CHIMERA ) then
            chimera_interpolation = .true.
            ndonors               = mesh(idom)%
        end if


        !
        ! Get domain/element index that is being differentiated
        !
        idom_seed  = seed%idom
        ielem_seed = seed%ielem
        


        !
        ! Allocate AD array to store a copy of the solution which starts the differentiation
        !
        nterms_s = mesh(idom)%faces(ielem,iface)%nterms_s
        allocate(qdiff(nterms_s), stat=ierr)
        if (ierr /= 0) call AllocationError



        !
        ! Get the number of degrees of freedom for the seed element
        ! and set this as the number of partial derivatives to track
        !
        if (ielem_seed == 0) then
            !
            ! If ielem_seed == 0 then we aren't interested in tracking derivatives
            !
            nderiv = 1
        else
            !
            ! Get number of equations and terms in solution expansions
            !
            neqns_seed    = mesh(idom_seed)%elems(ielem_seed)%neqns
            nterms_s_seed = mesh(idom_seed)%elems(ielem_seed)%nterms_s

            !
            ! Compute number of unknowns in the seed element, which is the number of partial derivatives we are tracking
            !
            nderiv = neqns_seed  *  nterms_s_seed
        end if



        !
        ! Allocate the derivative array for each autodiff variable
        ! MIGHT NOT NEED THIS IF IT GETS AUTOMATICALLY ALLOCATED ON ASSIGNMENT -- TEST
        !
        do igq = 1,size(var_gq)
            allocate(var_gq(igq)%xp_ad_(nderiv))
        end do



        !
        ! If the current element is being differentiated (ielem == ielem_seed)
        ! then copy the solution modes to local AD variable and seed derivatives
        !
        linearize_me = ( (idom == idom_seed) .and. (ielem == ielem_seed) )

        if ( linearize_me ) then

            !
            ! Allocate derivative arrays for temporary solution variable
            !
            do iterm = 1,nterms_s
                allocate(qdiff(iterm)%xp_ad_(nderiv))
            end do

            !
            ! Copy the solution variables from 'q' to 'qdiff'
            !
            qdiff = q%dom(idom)%lvecs(ielem)%getvar(ivar)


            !
            ! Loop through the terms in qdiff
            !
            do iterm = 1,size(qdiff)
                ! For the given term, seed its appropriate derivative
                set_deriv = (ivar - 1)*nterms_s + iterm
                qdiff(iterm)%xp_ad_(set_deriv) = 1.0_rk
            end do

            !
            ! Interpolate solution to GQ nodes via matrix-vector multiplication
            !
            var_gq = matmul(mesh(idom)%faces(ielem,iface)%gq%face%val(:,:,iface),  qdiff)

        else

            !
            ! If the solution variable derivatives dont need initialized
            ! then just use the q(ielem) values and derivatives get
            ! initialized to zero
            !
            var_gq = matmul(mesh(idom)%faces(ielem,iface)%gq%face%val(:,:,iface),  q%dom(idom)%lvecs(ielem)%getvar(ivar))
        end if


    end subroutine













    !> Compute variable at quadrature nodes.
    !!
    !!
    !!
    !!
    !----------------------------------------------------------------
    subroutine interpolate_element_standard(mesh,q,idom,ielem,ivar,var_gq)
        type(mesh_t),           intent(in)      :: mesh(:)
        type(chidgVector_t),    intent(in)      :: q
        integer(ik),            intent(in)      :: idom
        integer(ik),            intent(in)      :: ielem
        integer(ik),            intent(in)      :: ivar
        real(rk),               intent(inout)   :: var_gq(:)

        !
        ! Use quadrature instance to compute variable at quadrature nodes.
        ! This takes the form of a matrix multiplication of the quadrature matrix
        ! with the array of modes for the given variable.
        !
        var_gq = matmul(mesh(idom)%elems(ielem)%gq%vol%val, q%dom(idom)%lvecs(ielem)%getvar(ivar))

    end subroutine













    !> Compute variable at quadrature nodes.
    !!
    !!
    !!
    !!
    !----------------------------------------------------------------
    subroutine interpolate_face_standard(mesh,q,idom,ielem,iface,ivar,var_gq)
        type(mesh_t),           intent(in)      :: mesh(:)
        type(chidgVector_t),    intent(in)      :: q
        integer(ik),            intent(in)      :: idom, ielem, iface, ivar
        real(rk),               intent(inout)   :: var_gq(:)


        !
        ! Use quadrature instance to compute variable at quadrature nodes.
        ! This takes the form of a matrix multiplication of the face quadrature matrix
        ! with the array of modes for the given variable
        !
        var_gq = matmul(mesh(idom)%faces(ielem,iface)%gq%face%val(:,:,iface), q%dom(idom)%lvecs(ielem)%getvar(ivar))



    end subroutine
















end module mod_interpolate







