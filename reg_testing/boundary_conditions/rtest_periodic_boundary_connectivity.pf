!-----------------------------------------------------------------------------------------------------
!!
!!       REGRESSSION TEST
!!  
!!       Testing convergence of Linear Advection implicit system. The expectation is that the system 
!!       converges in one Newton iteration, since the governing equations are linear. The test for this
!!       is then to ensure that two inner iterations(Newton iterations) were executed for one step 
!!       in the backward-euler time-scheme. The first Newton iteration should converge the system.
!!       The second Newton iteration should then compute a residual of machine-zero and exit the loop.
!!
!!
!!
!------------------------------------------------------------------------------------------------------
@Test
subroutine rtest_periodic_boundary_connectivity()
    use pfunit_mod
    use mod_kinds,          only: rk,ik
    use mod_constants,      only: ZERO, XI_MIN, ETA_MIN, ZETA_MIN, XI_MAX, ETA_MAX, ZETA_MAX, &
                                  ONE, TWO, THREE, FOUR, FIVE

    use type_chidg,         only: chidg_t
    use type_point,         only: point_t

    use mod_grid_operators, only: initialize_variable
    use atype_function,     only: function_t
    use mod_function,       only: create_function
    use mod_testutils,      only: meshgen
    use type_dict,          only: dict_t
    use mod_io
    implicit none

    type(chidg_t)                       :: chidg
    type(point_t),          allocatable :: pts(:,:,:)
    class(function_t),      allocatable :: fcn
    type(dict_t)                        :: toptions
    integer(ik)                         :: nterms_c, itime, ielem





    !============================================================================
    !
    ! Define input data here that is normally read through the namelist input file
    !
    !
    !============================================================================
    basis          = 'legendre'
    nterms_s       = 8
    gq_rule        = 2
    eqnset         = 'euler'
    timescheme     = 'backward_euler'
    matrixsolver   = 'gaussseidel'


    !============================================================================


    ! Set time-scheme options to pass during initialization
    call toptions%set('dt',0.1_rk)
    call toptions%set('tol',1.e-13_rk)
    call toptions%set('nsteps',100)
    call toptions%set('nwrite',0)



    !
    ! Initialize ChiDG environment.
    !
    call chidg%init('env')   



    !
    ! Set ChiDG components
    !
    call chidg%set('time_scheme',timescheme,toptions)
    call chidg%set('matrixsolver',matrixsolver)
    call chidg%set('ndomains','')


    !
    ! Generate points for mesh
    !
    call meshgen('15x15x3',pts)
     



    associate ( dom => chidg%domains(1) )
        !
        ! Initialize domain
        !
        nterms_c = 8
        call dom%init_geom(nterms_c,pts)
        call dom%init_bc('periodic',XI_MIN)
        call dom%init_bc('periodic',ETA_MIN)
        call dom%init_bc('periodic',ZETA_MIN)
        call dom%init_sol(eqnset,nterms_s)


        !
        ! Initialize solution
        !
        call create_function(fcn,'isentropic_vortex')
        call fcn%set('xo',3.5_rk)
        call fcn%set('yo',3.5_rk)
        call fcn%set('zo',0.5_rk)
        call fcn%set('uinf',ZERO)
        call fcn%set('vinf',ZERO)


        call fcn%set('var',ONE)
        call initialize_variable(dom,1,fcn)
        call fcn%set('var',TWO)
        call initialize_variable(dom,2,fcn)
        call fcn%set('var',THREE)
        call initialize_variable(dom,3,fcn)
        call fcn%set('var',FOUR)
        call initialize_variable(dom,4,fcn)
        call fcn%set('var',FIVE)
        call initialize_variable(dom,5,fcn)
    end associate


    !
    ! Wrap-up initialization activities
    !
    call chidg%init('finalize')








    ! Check connectivity of periodic boundaries for a few elements
    ! Test element 1
    ielem = 1
    @assertEqual(15,chidg%domains(1)%mesh%faces(ielem,XI_MIN)%ineighbor)
    @assertEqual(2,chidg%domains(1)%mesh%faces(ielem,XI_MAX)%ineighbor)
    @assertEqual(211,chidg%domains(1)%mesh%faces(ielem,ETA_MIN)%ineighbor)
    @assertEqual(16,chidg%domains(1)%mesh%faces(ielem,ETA_MAX)%ineighbor)
    @assertEqual(451,chidg%domains(1)%mesh%faces(ielem,ZETA_MIN)%ineighbor)
    @assertEqual(226,chidg%domains(1)%mesh%faces(ielem,ZETA_MAX)%ineighbor)




    ! Test element 211
    ielem = 211
    @assertEqual(225,chidg%domains(1)%mesh%faces(ielem,XI_MIN)%ineighbor)
    @assertEqual(212,chidg%domains(1)%mesh%faces(ielem,XI_MAX)%ineighbor)
    @assertEqual(196,chidg%domains(1)%mesh%faces(ielem,ETA_MIN)%ineighbor)
    @assertEqual(1,chidg%domains(1)%mesh%faces(ielem,ETA_MAX)%ineighbor)
    @assertEqual(661,chidg%domains(1)%mesh%faces(ielem,ZETA_MIN)%ineighbor)
    @assertEqual(436,chidg%domains(1)%mesh%faces(ielem,ZETA_MAX)%ineighbor)











end subroutine
